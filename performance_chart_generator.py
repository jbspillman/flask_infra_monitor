from datetime import datetime, timedeltaimport colorsysimport randomimport timeimport jsonimport osdef generate_monitoring_dashboard(json_file_path, output_file_path="monitoring_dashboard.html", hour_limit=24):    """    Generate an HTML monitoring dashboard from JSON system monitoring data.    Dynamically handles any number of servers and metrics.    Args:        json_file_path (str): Path to the JSON file containing monitoring data        output_file_path (str): Path where the HTML file will be saved        hour_limit (int): Number of hours to return    """    html_base_name = os.path.basename(output_file_path)    site_str = html_base_name.split('__')[0]    product_str = html_base_name.split('__')[1].replace('-', ' ').replace('.html', '')    # Read and parse the JSON data    try:        with open(json_file_path, 'r') as file:            data = json.load(file)    except FileNotFoundError:        # print(f"Error: File {json_file_path} not found.")        return    except json.JSONDecodeError:        # print(f"Error: Invalid JSON in file {json_file_path}.")        return    # Filter data to last XX hours    def filter_last_xx_hours(server_data_lcl):        """Filter data points to only include last XX hours"""        if not server_data_lcl:            return []        # Find the latest timestamp        latest_time = None        for point in server_data_lcl:            try:                point_time = datetime.strptime(point['timestamp'], "%Y-%m-%d %H:%M:%S")                if latest_time is None or point_time > latest_time:                    latest_time = point_time            except (ValueError, KeyError):                continue        if latest_time is None:            return server_data_lcl  # Return original if no valid timestamps        # Calculate XX hours ago from latest time        cutoff_time = latest_time - timedelta(hours=hour_limit)        # Filter data points        filtered_data_local = []        for point in server_data:            try:                point_time = datetime.strptime(point['timestamp'], "%Y-%m-%d %H:%M:%S")                if point_time >= cutoff_time:                    filtered_data_local.append(point)            except (ValueError, KeyError):                # Keep points with invalid timestamps (shouldn't happen in good data)                filtered_data_local.append(point)        return filtered_data_local    # Extract server information dynamically and filter to last XX hours    servers = []    all_metrics = set()    filtered_data = []    for server_obj in data:        filtered_server_obj = {}        for server_name, server_data in server_obj.items():            servers.append(server_name)            # Filter to last XX hours            filtered_server_data = filter_last_xx_hours(server_data)            filtered_server_obj[server_name] = filtered_server_data            if filtered_server_data:  # Make sure there's data after filtering                # Get all metrics from the first data point                all_metrics.update(filtered_server_data[0].keys())        filtered_data.append(filtered_server_obj)    # Remove 'timestamp' from metrics as it's not a chart metric    all_metrics.discard('timestamp')    all_metrics = sorted(list(all_metrics))  # Sort for consistent ordering    # print(f"Found {len(servers)} servers: {servers}")    # print(f"Found {len(all_metrics)} metrics: {all_metrics}")    # Generate colors for servers    def generate_colors(num_colors):        colors = []        for i in range(num_colors):            hue = i / num_colors            rgb = colorsys.hsv_to_rgb(hue, 0.8, 0.9)            hex_color = '#{:02x}{:02x}{:02x}'.format(                int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255)            )            colors.append(hex_color)        return colors    server_colors = generate_colors(len(servers))    # Convert filtered Python data to JavaScript format    js_data = json.dumps(filtered_data, indent=8)    # Generate legend HTML    legend_html = ""    for i, server in enumerate(servers):        legend_html += f'''                    <div class="legend-item">                        <div class="legend-color" style="background-color: {server_colors[i]};"></div>                        <span>{server}</span>                    </div>'''    # Generate metric cards HTML    metric_cards_html = ""    for metric in all_metrics:        # Create a readable title from the metric name        metric_title = metric.replace('_', ' ').title()        metric_cards_html += f'''                <div class="metric-card">                    <div class="metric-title">{metric_title}</div>                    <div class="chart-wrapper">                        <canvas id="{metric}Chart"></canvas>                    </div>                </div>'''    # Generate chart creation JavaScript    charts_js = ""    for metric in all_metrics:        # Determine unit suffix based on metric name        unit_suffix = ""        if "percent" in metric or "%" in metric:            unit_suffix = "'%'"            y_scale_options = """                            min: 0,                            max: 100,"""        elif "gb" in metric.lower() or "memory" in metric.lower():            unit_suffix = "' GB'"            y_scale_options = ""        elif "mbps" in metric.lower() or "mb" in metric.lower():            unit_suffix = "' MB/s'"            y_scale_options = ""        elif "ms" in metric.lower() or "latency" in metric.lower():            unit_suffix = "' ms'"            y_scale_options = ""        else:            unit_suffix = "''"            y_scale_options = ""        charts_js += f'''            // {metric.replace('_', ' ').title()} Chart            var {metric}Chart = new Chart(document.getElementById('{metric}Chart'), {{                ...chartConfig,                data: {{                    labels: timeLabels,                    datasets: createDatasets('{metric}', serverColors)                }},                options: {{                    ...chartConfig.options,                    scales: {{                        ...chartConfig.options.scales,                        y: {{                            ...chartConfig.options.scales.y,{y_scale_options}                            ticks: {{                                callback: function(value) {{                                    return value + {unit_suffix};                                }}                            }}                        }}                    }}                }}            }});    '''    # HTML template with dynamic content    nanoseconds_since_epoch = time.time_ns()    chart_data_variable = f'cData_{str(nanoseconds_since_epoch)}'    html_template = f'''    <div class="container">        <div class="header">            <h2>{site_str.upper()} : {product_str}</h2>            <p>Real-time performance metrics for {len(servers)} server{'s' if len(servers) != 1 else ''} (Last {hour_limit} Hours)</p>                        <div class="server-legend"> {legend_html}</div>        </div>        <div class="stats-summary">            <div class="stats-grid">                <div class="stat-item">                    <div class="stat-value">{len(servers)}</div>                    <div class="stat-label">Servers Monitored</div>                </div>                <div class="stat-item">                    <div class="stat-value">{len(all_metrics)}</div>                    <div class="stat-label">Metrics Tracked</div>                </div>                <div class="stat-item">                    <div class="stat-value" id="dataPoints">-</div>                    <div class="stat-label">Data Points</div>                </div>                <div class="stat-item">                    <div class="stat-value" id="timeRange">-</div>                    <div class="stat-label">Time Range</div>                </div>            </div>        </div>        <div class="metrics-grid">{metric_cards_html}        </div>                <div class="footer">            <p>Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")} | Data source: {os.path.basename(json_file_path)}</p>        </div>    </div>    <script>        // Parse the JSON data        var {chart_data_variable} = {js_data};                // Extract server information dynamically        var servers = {json.dumps(servers)};        var serverColors = {json.dumps(server_colors)};        var metrics = {json.dumps(all_metrics)};                // Create server data mapping        var serverDataMap = {{}};        {chart_data_variable}.forEach(serverObj => {{            Object.keys(serverObj).forEach(serverName => {{                serverDataMap[serverName] = serverObj[serverName];            }});        }});                // Get time labels from the first server's data        var firstServerData = Object.values(serverDataMap)[0];        var timeLabels = firstServerData.map(item => {{            var date = new Date(item.timestamp);            return date.toLocaleTimeString('en-US', {{                 hour: '2-digit',                 minute: '2-digit',                second: '2-digit'            }});        }});                // Update stats        var totalDataPoints = Object.values(serverDataMap).reduce((sum, {chart_data_variable}) => sum + {chart_data_variable}.length, 0);        document.getElementById('dataPoints').textContent = totalDataPoints;                if (firstServerData.length > 0) {{            var firstTime = new Date(firstServerData[0].timestamp);            var lastTime = new Date(firstServerData[firstServerData.length - 1].timestamp);            var timeDiff = Math.round((lastTime - firstTime) / 1000 / 60); // minutes            document.getElementById('timeRange').textContent = timeDiff + ' min';        }}        // Chart configuration        var chartConfig = {{            type: 'line',            options: {{                responsive: true,                maintainAspectRatio: false,                interaction: {{                    intersect: false,                    mode: 'index'                }},                plugins: {{                    legend: {{                        display: true,                        position: 'top'                    }}                }},                scales: {{                    x: {{                        grid: {{                            color: '#f0f0f0'                        }}                    }},                    y: {{                        grid: {{                            color: '#f0f0f0'                        }}                    }}                }}            }}        }};        // Create datasets function        function createDatasets(metric, colors) {{            return servers.map((serverName, index) => {{                var serverData = serverDataMap[serverName];                return {{                    label: serverName,                    data: serverData.map(item => item[metric]),                    borderColor: colors[index],                    backgroundColor: colors[index] + '20',                    borderWidth: 2,                    tension: 0.4,                    pointBackgroundColor: colors[index],                    pointBorderColor: '#fff',                    pointBorderWidth: 2,                    pointRadius: 4                }};            }});        }}        // Create all charts dynamically        {charts_js}        </script>    '''    # Write the HTML file    try:        with open(output_file_path, 'w') as file:            file.write(html_template)        # print(f"Dashboard successfully generated: {output_file_path}")        return output_file_path    except Exception as e:        # print(f"Error writing HTML file: {e}")        return Nonedef analyze_json_structure(json_file_path):    """    Analyze the JSON file structure and provide detailed information    """    try:        with open(json_file_path, 'r') as file:            data = json.load(file)        # print("=== JSON Structure Analysis ===")        # print(f"Root structure: {type(data).__name__}")        if isinstance(data, list):            # print(f"Number of server objects: {len(data)}")            servers = []            all_metrics = set()            for i, server_obj in enumerate(data):                if isinstance(server_obj, dict):                    for server_name, server_data in server_obj.items():                        servers.append(server_name)                        # print(f"  Server {i+1}: {server_name}")                        # print(f"    Data points: {len(server_data) if server_data else 0}")                        if server_data and isinstance(server_data, list) and len(server_data) > 0:                            sample_point = server_data[0]                            metrics = list(sample_point.keys())                            all_metrics.update(metrics)                            # print(f"    Sample metrics: {metrics}")            # print(f"\nUnique metrics across all servers: {sorted(list(all_metrics))}")            # print(f"Total servers found: {len(servers)}")        return True    except Exception as e:        # print(f"Error analyzing JSON: {e}")        return Falsedef generate_sample_data_multiple_servers(output_file="sample_monitoring_data_multi.json", num_servers=4, num_points=10):    """    Generate sample monitoring data for multiple servers with various metrics    """    from datetime import datetime, timedelta    base_time = datetime(2025, 8, 16, 18, 59, 16)    # Define various possible metrics    metric_templates = [        {"name": "cpu_usage_percent", "range": (10, 100), "unit": "%"},        {"name": "memory_usage_gb", "range": (2, 32), "unit": "GB"},        {"name": "disk_io_mbps", "range": (50, 500), "unit": "MB/s"},        {"name": "network_latency_ms", "range": (10, 150), "unit": "ms"},        {"name": "process_count", "range": (50, 300), "unit": "count"},        {"name": "disk_usage_percent", "range": (20, 95), "unit": "%"},        {"name": "network_throughput_mbps", "range": (100, 1000), "unit": "MB/s"},        {"name": "active_connections", "range": (10, 500), "unit": "count"},    ]    def generate_server_data(server_name, num_points):        data = []        for i in range(num_points):            timestamp = base_time + timedelta(minutes=i*2)            point = {"timestamp": timestamp.strftime("%Y-%m-%d %H:%M:%S")}            # Add random metrics (not all servers need all metrics)            num_metrics = random.randint(4, len(metric_templates))            selected_metrics = random.sample(metric_templates, num_metrics)            for metric in selected_metrics:                if metric["unit"] == "count":                    point[metric["name"]] = random.randint(int(metric["range"][0]), int(metric["range"][1]))                else:                    point[metric["name"]] = round(random.uniform(metric["range"][0], metric["range"][1]), 2)            data.append(point)        return data    # Generate server names    server_names = [                       f"prod-web-{i:02d}" for i in range(1, num_servers//2 + 1)                   ] + [                       f"prod-db-{i:02d}" for i in range(1, num_servers//2 + 1)                   ]    if len(server_names) < num_servers:        server_names.extend([f"prod-app-{i:02d}" for i in range(1, num_servers - len(server_names) + 1)])    sample_data = []    for server_name in server_names[:num_servers]:        sample_data.append({server_name: generate_server_data(server_name, num_points)})    with open(output_file, 'w') as file:        json.dump(sample_data, file, indent=4)    # print(f"Sample data for {num_servers} servers generated: {output_file}")    return output_filedef create_report_from_file(json_file, html_file):    """    do the good chart stuff :)    """    # print("=== System Monitoring Dashboard Generator ===")    if os.path.exists(json_file):        # print(f"\n1. Analyzing existing file: {json_file}")        analyze_json_structure(json_file)        # print(f"\n2. Generating dashboard from: {json_file}")        generate_monitoring_dashboard(json_file, html_file, 12)    else:        print(f"\nFile {json_file} not found. Generating sample data...")    # Example 2: Generate sample data with multiple servers    # # print(f"\n3. Generating sample data with multiple servers...")    # sample_file = generate_sample_data_multiple_servers("sample_multi_server.json", num_servers=5, num_points=15)    #    # # print(f"\n4. Generating dashboard from sample data...")    # generate_monitoring_dashboard(sample_file, "sample_dashboard.html")    #    # # print(f"\n5. Analyzing sample data structure...")    # analyze_json_structure(sample_file)# input = r"ap-jp-north-west-01__Dell-PowerEdge.json"# ouput = r"ap-jp-north-west-01__Dell-PowerEdge.html"# create_report_from_file(input, ouput)